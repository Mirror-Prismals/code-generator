#!/usr/bin/env python3
# synthetic_lilypond.py · v0.1.0
"""
Generate synthetic LilyPond files with random notes, chords, rests, dynamics, and articulations.

Major features
--------------
* Deterministic output with --seed
* Configurable number of measures and voices
* Plugin architecture for new snippet generators
* Random clefs, time signatures, key signatures
* Random note durations, pitches, chords, rests, dynamics, articulations
* --out to save directly to disk

Usage
-----
python synthetic_lilypond.py 16            # 16 measures, 1 voice
python synthetic_lilypond.py 32 --voices 2 --seed 42 --out score.ly
"""
from __future__ import annotations

import argparse
import random
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Dict, List

__version__ = "0.1.0"

@dataclass(frozen=True)
class LilyConfig:
    measures: int = 16
    voices: int = 1
    seed: int | None = None
    out: Path | None = None

GeneratorFn = Callable[[Dict], str]
_REGISTRY: Dict[str, GeneratorFn] = {}

def register(kind: str) -> Callable[[GeneratorFn], GeneratorFn]:
    def decorator(fn: GeneratorFn) -> GeneratorFn:
        if kind in _REGISTRY:
            raise ValueError(f"Duplicate generator: {kind}")
        _REGISTRY[kind] = fn
        return fn
    return decorator

PITCHES = ['c', 'd', 'e', 'f', 'g', 'a', 'b']
ALTERS  = ['', 'is', 'es']   # sharp, flat
DURATIONS = ['1', '2', '4', '8', '16']
DYNAMICS = ['\\pp', '\\p', '\\mp', '\\mf', '\\f', '\\ff']
ARTICS   = ["\\staccato", "\\tenuto", "\\accent"]

@register("clef")
def gen_clef(state: Dict) -> str:
    return random.choice(["\\clef treble", "\\clef bass"]) + "\n"

@register("time")
def gen_time(state: Dict) -> str:
    # choose common meters
    meter = random.choice(["4/4", "3/4", "6/8", "2/4"])
    return f"\\time {meter}\n"

@register("key")
def gen_key(state: Dict) -> str:
    tonic = random.choice(PITCHES).capitalize()
    mode = random.choice(['major', 'minor'])
    return f"\\key {tonic} \\{mode}\n"

@register("note")
def gen_note(state: Dict) -> str:
    rng = state["rng"]
    pitch = rng.choice(PITCHES) + rng.choice(ALTERS)
    duration = rng.choice(DURATIONS)
    dyn = rng.choice(DYNAMICS) if rng.random() < 0.2 else ""
    artic = rng.choice(ARTICS) if rng.random() < 0.1 else ""
    return f"{pitch}{duration}{dyn}{artic} "

@register("chord")
def gen_chord(state: Dict) -> str:
    rng = state["rng"]
    # build triad
    root = rng.choice(PITCHES) + rng.choice(ALTERS)
    third = rng.choice(PITCHES) + rng.choice(ALTERS)
    fifth = rng.choice(PITCHES) + rng.choice(ALTERS)
    duration = rng.choice(DURATIONS)
    return f"<{root} {third} {fifth}>{duration} "

@register("rest")
def gen_rest(state: Dict) -> str:
    rng = state["rng"]
    duration = rng.choice(DURATIONS)
    return f"r{duration} "

@register("barline")
def gen_barline(state: Dict) -> str:
    return "|\n"

def build_voice(state: Dict, cfg: LilyConfig) -> str:
    rng = state["rng"]
    measures = []
    for _ in range(cfg.measures):
        # each measure ~4 beats; fill with ~4 elements
        elems = []
        for _ in range(4):
            kind = rng.choices(
                ['note','rest','chord'],
                weights=[0.6,0.2,0.2],
                k=1
            )[0]
            elems.append(_REGISTRY[kind](state).strip())
        measure = " ".join(elems) + " |"
        measures.append(measure)
    return "  { " + " ".join(measures) + " }\n"

def build_lily(cfg: LilyConfig) -> str:
    rng = random.Random(cfg.seed)
    state: Dict = {"rng": rng}
    parts: List[str] = [
        f"%% generated by synthetic_lilypond.py v{__version__}\n",
        "\\version \"2.22.0\"\n",
        "\\score {\n"
    ]
    for v in range(cfg.voices):
        parts.append(f"  <<\n    \\new Staff \\relative c' \n")
        # optional clef, time, key at start of each voice
        parts.append("    " + _REGISTRY["clef"](state))
        parts.append("    " + _REGISTRY["time"](state))
        parts.append("    " + _REGISTRY["key"](state))
        parts.append(build_voice(state, cfg))
        parts.append("  >>\n")
    parts.append("  \\layout { }\n")
    parts.append("  \\midi { }\n")
    parts.append("}\n")
    return "".join(parts)

def _cli() -> None:
    p = argparse.ArgumentParser(description="Generate synthetic LilyPond file.")
    p.add_argument("measures", nargs="?", type=int, default=16,
                   help="Number of measures per voice")
    p.add_argument("--voices", type=int, default=1,
                   help="Number of voices/staves")
    p.add_argument("--seed", type=int, help="Random seed")
    p.add_argument("--out", type=Path, help="Path to save generated .ly")
    args = p.parse_args()

    cfg = LilyConfig(measures=args.measures, voices=args.voices,
                     seed=args.seed, out=args.out)
    lily = build_lily(cfg)

    if cfg.out:
        cfg.out.parent.mkdir(parents=True, exist_ok=True)
        cfg.out.write_text(lily, encoding="utf-8")
        print(f"✔ Saved synthetic LilyPond to {cfg.out}")
    else:
        sys.stdout.write(lily)

if __name__ == "__main__":
    _cli()
